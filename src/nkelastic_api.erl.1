%% -------------------------------------------------------------------
%%
%% Copyright (c) 2017 Carlos Gonzalez Florido.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @doc NkELASTIC external API

-module('nkelastic_api.erl').
-author('Carlos Gonzalez <carlosj.gf@gmail.com>').

-export([health/2, get_nodes/2]).
-export([list_indices/2, get_indices/2, get_index/3]).
-export([get_count/2, get_count/3]).
-export([create_index/4, delete_index/3, update_index/4, update_or_create_index/4]).
-export([get_template/3, create_template/4, delete_template/3, get_all_templates/2]).
-export([update_analysis/4, add_mapping/5]).
-export([get_aliases/2, get_aliases/3, add_alias/5, delete_alias/4]).
-export([get/5, put/6, put_and_wait/6, delete/5, delete_and_wait/5, delete_by_query/5, delete_all/4]).
-export([search/, count/4, explain/4, iterate_start/4, iterate_next/2, iterate_fun/6]).

-type srv_id(), cluster_id() :: nkservice:srv_id(), cluster_id().
-type index() :: binary() | string().
-type obj_srv_id(), cluster_id() :: binary() | string().
-type type() :: binary() | string().
-type error() :: {es_error, binary(), binary()} | term().
-type status() :: geen | yellow | red.
-type query() :: nkelastic_search:query().

% https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html

%% ===================================================================
%% Public
%% ===================================================================

%% @doc Gets cluster health
-spec health(srv_id(), cluster_id()) ->
	{ok, status(), map()} | {error, error()}.

health(SrvId, Cluster) ->
    case request(SrvId, Cluster, get, "_cluster/health") of
    	{ok, #{<<"status">>:=Status}=Data} ->
    		{ok, binary_to_atom(Status, latin1), Data};
    	{error, Error} ->
    		{error, Error}
    end.


%% @doc Gets node info
%% https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-nodes.html
-spec get_nodes(srv_id(), cluster_id()) ->
	{ok, [map()]} | {error, error()}.

get_nodes(SrvId, Cluster) ->
    request(SrvId, Cluster, get, "_cat/nodes?format=json").


%% @doc Lists all indices
-spec list_indices(srv_id(), cluster_id()) ->
	{ok, [binary()]} | {error, error()}.

list_indices(SrvId, Cluster) ->
    request_lines(SrvId, Cluster, get, "_cat/indices?h=index").


%% @doc Gets all indices with detailed info
-spec get_indices(srv_id(), cluster_id()) ->
	{ok, map()} | {error, error()}.

get_indices(SrvId, Cluster) ->
    request(SrvId, Cluster, get, "_all").


%% @doc Gets info about and index
-spec get_index(srv_id(), cluster_id(), index()) ->
	{ok, map()} | {error, error()}.

get_index(SrvId, Cluster, Index) ->
    request(SrvId, Cluster, get, Index).


%% @doc Get number of objects
-spec get_count(srv_id(), cluster_id()) ->
	{ok, integer()} | {error, error()}.

get_count(SrvId, Cluster) ->
    get_count(SrvId, Cluster, all).


%% @doc Get number of objects for an index
-spec get_count(srv_id(), cluster_id(), index()) ->
	{ok, integer()} | {error, error()}.

get_count(SrvId, Cluster, Index) ->
	Msg = ["_cat/count", post_index(Index), "?h=count"],
    case request_lines(SrvId, Cluster, get, Msg) of
        {ok, [Count]} ->
            {ok, to_int(Count)};
        {error, Error} ->
            {error, Error}
    end.

%% @doc Creates an index
%% Name: letters, numbers, ".,-&_"
%% Options: number_of_shards, number_of_replicas, index_refresh_interval
%% Also aliases (#{aliases => #{alias1 => #{}})
%% and mappings (#{mappings => #{type1 => #{properties => ...}}})
-spec create_index(srv_id(), cluster_id(), index(), map()) ->
	ok | {error, error()}.

create_index(SrvId, Cluster, Index, Opts) ->
    Body = index_params(Opts),
    request(SrvId, Cluster, put, Index, Body).


%% @doc Deletes an index
-spec delete_index(srv_id(), cluster_id(), index()) ->
	ok | {error, error()}.

delete_index(SrvId, Cluster, Index) ->
    request(SrvId, Cluster, delete, Index).


%% @doc Updates an index
%% Options: refresh_interval, number_of_replicas
-spec update_index(srv_id(), cluster_id(), index(), map()) ->
	ok | {error, error()}.

update_index(SrvId, Cluster, Index, Opts) ->
    Body = #{index => Opts},
    request(SrvId, Cluster, put, [Index, "/_settings"], Body).


%% @doc Updates analysis
-spec update_analysis(srv_id(), cluster_id(), index(), map()) ->
	ok | {error, error()}.

update_analysis(SrvId, Cluster, Index, Opts) ->
    Body = #{analysis => Opts},
    request(SrvId, Cluster, put, [Index, "/_settings"], Body).


%% @doc Tries to update an index, or create it
%% Options
update_or_create_index(SrvId, Cluster, Index, Opts) ->
    case update_index(SrvId, Cluster, Index, Opts) of
        {error, {index_not_found, _}} ->
            lager:info("NkELASTIC: Index ~s not found, creating it", [Index]),
            create_index(SrvId, Cluster, Index, Opts);
        Other ->
            Other
    end.


%% @doc Creates an index template
%% Same parameters as for indices
-spec create_template(srv_id(), cluster_id(), Name::binary(), map()) ->
    ok | {error, error()}.

create_template(SrvId, Cluster, Name, #{template:=Template}=Opts) ->
    Body1 = index_params(maps:remove(template, Opts)),
    Body2 = Body1#{template=>to_bin(Template)},
    request(SrvId, Cluster, put, ["_template/", Name], Body2).


%% @doc Deletes an template
-spec delete_template(srv_id(), cluster_id(), Name::binary()) ->
    ok | {error, error()}.

delete_template(SrvId, Cluster, Name) ->
    request(SrvId, Cluster, delete, ["_template/", Name]).


%% @doc Gets a template
-spec get_template(srv_id(), cluster_id(), Name::binary()) ->
    {ok, map()} | {error, error()}.

get_template(SrvId, Cluster, Name) ->
    request(SrvId, Cluster, get, ["_template/", Name]).


%% @doc Gets all templates
-spec get_all_templates(srv_id(), cluster_id()) ->
    {ok, [binary()]} | {error, error()}.

get_all_templates(SrvId, Cluster) ->
    case request(SrvId, Cluster, get, "_template") of
        {ok, Map} ->
            {ok, maps:keys(Map)};
        {error, Error} ->
            {error, Error}
    end.


%% @doc Set a mapping
%% https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html
%% Sample:
%% #{
%%    '_all' => #{disabled=>true},
%%    id => #{type=>string, store=>yes, index=>not_analyzed}
%%}
%% Metafields: https://www.elastic.co/guide/en/elasticsearch/
%%                     reference/current/mappnkseing-fields.html
-spec add_mapping(srv_id(), cluster_id(), index(), type(), map()) ->
	ok | {error, term()}.

add_mapping(SrvId, Cluster, Index, Type, Mappings) ->
    {Metas, Props} = extract_mappings(Mappings),
    Body = Metas#{properties=>Props},
    request(SrvId, Cluster, put, [Index, "/", to_bin(Type), "/_mapping"], Body).


%% @doc Get all indices and their aliases
-spec get_aliases(srv_id(), cluster_id()) ->
	{ok, #{index() => [Alias::binary()]}} | {error, error()}.

get_aliases(SrvId, Cluster) ->
    case request(SrvId, Cluster, get, ["_aliases"]) of
    	{ok, Map} ->
    		List = lists:foldl(
    			fun({Index, #{<<"aliases">>:=Aliases}}, Acc) ->
    				[{Index, maps:keys(Aliases)}|Acc]
    			end,
    			[],
    			maps:to_list(Map)),
    		{ok, maps:from_list(List)};
    	{error, Error} ->
    		{error, Error}
    end.


%% @doc Get aliases for an index
-spec get_aliases(srv_id(), cluster_id(), index()) ->
	{ok, #{index() => [Alias::binary()]}}.

get_aliases(SrvId, Cluster, Index) ->
    case request(SrvId, Cluster, get, [Index, "/_aliases"]) of
    	{ok, Map} ->
    		[{_, #{<<"aliases">>:=Aliases}}] = maps:to_list(Map),
    		{ok, maps:keys(Aliases)};
    	{error, Error} ->
    		{error, Error}
    end.


%% @doc Adds an alias to an index
%% Opts can include
% #{filter => #{key=>val}, index_routing=>... search_routing=>...}
-spec add_alias(srv_id(), cluster_id(), index(), binary(), map()) ->
	ok | {error, term()}.

add_alias(SrvId, Cluster, Index, Name, Opts) ->
    request(SrvId, Cluster, put, [Index, "/_aliases/", to_bin(Name)], Opts).


%% @doc Removes an alias from an index
-spec delete_alias(srv_id(), cluster_id(), index(), binary()) ->
	ok | {error, term()}.

delete_alias(SrvId, Cluster, Index, Name) ->
    request(SrvId, Cluster, delete, [Index, "/_alias/", to_bin(Name)]).



%% @doc Gets an object by id
-spec get(srv_id(), cluster_id(), index(), type(), obj_srv_id(), cluster_id()) ->
	{ok, map(), integer()} | {error, term()}.

get(SrvId, Cluster, Index, Type, ObjId) ->
    case request(SrvId, Cluster, get, [Index, "/", to_bin(Type), "/", ObjId]) of
    	{ok, #{
    		<<"_source">> := Src,
    		<<"_version">> := Vsn
    	}} ->
    		{ok, Src, Vsn};
    	{error, Error} ->
    		{error, Error}
    end.


%% @doc Puts an object by id
-spec put(srv_id(), cluster_id(), index(), type(), obj_srv_id(), cluster_id(), map()) ->
	{ok, integer()} | {error, term()}.

put(SrvId, Cluster, Index, Type, ObjId, Obj) ->
    case request_data(SrvId, Cluster, put, [Index, "/", to_bin(Type), "/", ObjId], Obj) of
    	{ok, #{<<"_version">>:=Vsn}} -> {ok, Vsn};
    	{error, Error} -> {error, Error}
    end.


%% @doc Puts an object by id
-spec put_and_wait(srv_id(), cluster_id(), index(), type(), obj_srv_id(), cluster_id(), map()) ->
    {ok, integer()} | {error, term()}.

put_and_wait(SrvId, Cluster, Index, Type, ObjId, Obj) ->
    case request_data(SrvId, Cluster, put, [Index, "/", to_bin(Type), "/", ObjId, "?refresh=true"], Obj) of
        {ok, #{<<"_version">>:=Vsn}} -> {ok, Vsn};
        {error, Error} -> {error, Error}
    end.


%% @doc Deletes an object by id
-spec delete(srv_id(), cluster_id(), index(), type(), obj_srv_id(), cluster_id()) ->
	ok | {error, term()}.

delete(SrvId, Cluster, Index, Type, ObjId) ->
    request(SrvId, Cluster, delete, [Index, "/", to_bin(Type), "/", ObjId]).


%% @doc Deletes an object by id
-spec delete_and_wait(srv_id(), cluster_id(), index(), type(), obj_srv_id(), cluster_id()) ->
    ok | {error, term()}.

delete_and_wait(SrvId, Cluster, Index, Type, ObjId) ->
    request(SrvId, Cluster, delete, [Index, "/", to_bin(Type), "/", ObjId, "?refresh=true"]).


%% @doc Deletes all objects from a query
-spec delete_by_query(srv_id(), cluster_id(), index(), type(), map()) ->
    {ok, map()} | {error, term()}.

delete_by_query(SrvId, Cluster, Index, Type, Query) ->
    Url =  index_url(delete_by_query, Index, Type, <<>>),
    request(SrvId, Cluster, post, Url, #{query=>Query}).


%% @doc Gets all objects having a type
-spec delete_all(srv_id(), cluster_id(), index(), type()) ->
    {ok, map()} | {error, term()}.

delete_all(SrvId, Cluster, Index, Type) ->
    delete_by_query(SrvId, Cluster, Index, Type, #{match_all=>#{}}).


%% @doc Search
%% Query can be generated with nkelastic_search:query/1
-spec search(srv_id(), cluster_id(), index(), type(), query()) ->
    {ok, integer(), Obj::[map()], Aggs::map(), Meta::map()} | {error, term()}.

search(SrvId, Cluster, Index, Type, Query) ->
    Url =  index_url(search, Index, Type, <<>>),
    case request(SrvId, Cluster, post, Url, Query) of
        {ok, Reply} ->
            #{
                <<"took">> := Time,
                <<"timed_out">> := TimedOut,
                <<"hits">>:= #{
                    <<"total">>:=Total, <<"hits">>:=Hits
                }
            } = Reply,
            %% lager:info("Query took ~p msecs", [Time]),
            %% lager:info("~s", [nklib_json:encode_pretty(Reply)]),
            Aggs = maps:get(<<"aggregations">>, Reply, #{}),
            Meta = #{time=>Time, timeout=>TimedOut},
            {ok, Total, Hits, Aggs, Meta};
        {error, Error} ->
            {error, Error}
    end.


%% @doc Count
-spec count(srv_id(), cluster_id(), index(), type(), query()) ->
    {ok, integer()} | {error, term()}.

count(SrvId, Cluster, Index, Type, Query) ->
    Url = index_url(count, Index, Type, <<>>),
    case request(SrvId, Cluster, post, Url, Query) of
        {ok, #{<<"count">>:=Count}} ->
            {ok, Count};
        {error, Error} ->
            {error, Error}
    end.


%% @doc Search explain
-spec explain(srv_id(), cluster_id(), index(), type(), query()) ->
    {ok, integer()} | {error, term()}.

explain(SrvId, Cluster, Index, Type, Query) ->
    Url = index_url(explain, Index, Type, <<>>),
    case request(SrvId, Cluster, post, Url, Query) of
        {ok, Data} ->
            {ok, Data};
        {error, Error} ->
            {error, Error}
    end.


%% @doc Iterate
-spec iterate_start(srv_id(), cluster_id(), index(), type(), query()) ->
    {ok, binary(), integer(), Obj::[map()], Meta::map()} | {error, term()}.

iterate_start(SrvId, Cluster, Index, Type, Query) ->
    Url =  index_url(search, Index, Type, <<"?scroll=1m">>),
    case request(SrvId, Cluster, post, Url, Query) of
        {ok, Reply} ->
            #{
                <<"_scroll_id">> := ScrollId,
                <<"took">> := Time,
                <<"timed_out">> := TimedOut,
                <<"hits">>:= #{
                    <<"total">>:=Total, <<"hits">>:=Hits
                }
            } = Reply,
            %% lager:info("Query took ~p msecs", [Time]),
            %% lager:info("~s", [nklib_json:encode_pretty(Reply)]),
            Meta = #{time=>Time, timeout=>TimedOut},
            {ok, ScrollId, Total, Hits, Meta};
        {error, Error} ->
            {error, Error}
    end.


%% @doc Search
-spec iterate_next(srv_id(), cluster_id(), binary()) ->
    {ok, binary(), integer(), Obj::[map()], Meta::map()} | {error, term()}.

iterate_next(SrvId, Cluster, ScrollId) ->
    Body = #{scroll => <<"1m">>, scroll_id=>ScrollId},
    case request(SrvId, Cluster, post, <<"_search/scroll">>, Body) of
        {ok, Reply} ->
            #{
                <<"_scroll_id">> := ScrollId2,
                <<"took">> := Time,
                <<"timed_out">> := TimedOut,
                <<"hits">>:= #{
                    <<"total">>:=Total, <<"hits">>:=Hits
                }
            } = Reply,
            %% lager:info("Query took ~p msecs", [Time]),
            %% lager:info("~s", [nklib_json:encode_pretty(Reply)]),
            Meta = #{time=>Time, timeout=>TimedOut},
            {ok, ScrollId2, Total, Hits, Meta};
        {error, Error} ->
            {error, Error}
    end.


%% @doc Iterate
-spec iterate_fun(srv_id(), cluster_id()), index(), type(), query(),
                  fun((map(), term()) -> {ok, term()} | {error, term()}), term()) ->
    {ok, term()} | {error, term()}.

iterate_fun(SrvId, Cluster, Index, Type, Query, Fun, Acc) ->
    case iterate_start(SrvId, Cluster, Index, Type, Query) of
        {ok, _ScrollId, _N, [], _} ->
            {ok, Acc};
        {ok, ScrollId, _N, Objs, _} ->
            case iterate_fun_fold(Objs, Fun, Acc) of
                {ok, Acc2} ->
                    iterate_fun2(SrvId, Cluster, ScrollId, Fun, Acc2);
                {error, Error} ->
                    {error, Error}
            end;
        {error, Error} ->
            {error, Error}
    end.


%% ===================================================================
%% Internal
%% ===================================================================

index_params(Opts) ->
    List = [
        {settings, #{index => maps:without([mappings, aliases], Opts)}},
        case maps:find(mappings, Opts) of
            {ok, Mappings} ->
                {mappings, Mappings};
            error ->
                []
        end,
        case maps:find(aliases, Opts) of
            {ok, Aliases} ->
                {aliases, Aliases};
            error ->
                []
        end
    ],
    maps:from_list(lists:flatten(List)).



%% @private
extract_mappings(Mappings) ->
    extract_mappings(maps:to_list(Mappings), [], []).


%% @private
extract_mappings([], Metas, Prop) ->
    {maps:from_list(Metas), maps:from_list(Prop)};

extract_mappings([{Key, Val}|Rest], Metas, Prop) ->
    case to_bin(Key) of
        <<"index">>=B ->
            extract_mappings(Rest, [{B, Val}|Metas], Prop);
        <<$_, _/binary>>=B ->
            extract_mappings(Rest, [{B, Val}|Metas], Prop);
        B ->
            extract_mappings(Rest, Metas, [{B, Val}|Prop])
    end.


%% @private
iterate_fun2(SrvId, Cluster, ScrollId, Fun, Acc) ->
    case iterate_next(SrvId, Cluster, ScrollId) of
        {ok, _ScrollId2, _N, [], _} ->
            {ok, Acc};
        {ok, ScrollId2, _N, Objs, _} ->
            case iterate_fun_fold(Objs, Fun, Acc) of
                {ok, Acc2} ->
                    iterate_fun2(SrvId, Cluster, ScrollId2, Fun, Acc2);
                {error, Error} ->
                    {error, Error}
            end;
        {error, Error} ->
            {error, Error}
    end.


%% @private
iterate_fun_fold([], _Fun, Acc) ->
    {ok, Acc};

iterate_fun_fold([Obj|Rest], Fun, Acc) ->
    case iterate_fun_process(Obj, Fun, Acc) of
        {ok, Acc2} ->
            iterate_fun_fold(Rest, Fun, Acc2);
        {error, Error} ->
            {error, Error}
    end.

%% @private
iterate_fun_process(#{<<"_id">>:=ObjId}=Data, Fun, Acc) ->
    Base = maps:get(<<"_source">>, Data, #{}),
    Obj = Base#{<<"obj_id">>=>ObjId},
    Fun(Obj, Acc).


%% @private
request(Method, Path, Opts) ->
    request(Method, Path, <<>>, Opts).


%% @private
request(Method, Path, Body, Opts) ->
    case request_data(Method, Path, Body, Opts) of
    	{ok, _} when Method==put; Method==delete -> ok;
    	{ok, Data} -> {ok, Data};
    	{error, Error} -> {error, Error}
   	end.


%% @private
request_data(Method, Path, Body, Opts) ->
    #{srv_id:=SrvId} = Opts,
    ClusterId = maps:get(cluster_id, Opts, <<"main">>),
    nkelastic_srv:request(SrvId, ClusterId, Method, Path, Body).


%% @private
request_lines(Method, Path, Opts) ->
    case request_data(Method, Path, <<>>, Opts) of
        {ok, List} ->
            List2 = binary:split(List, <<"\n">>, [global]),
            [<<>> | List3] = lists:reverse(List2),
            {ok, lists:reverse(List3)};
        {error, Error} ->
            {error, Error}
    end.


%% @private
index_url(Op, Index, Type, Str) ->
    case Type of
        <<>> ->    [Index, "/_", to_bin(Op), Str];
        <<"*">> -> [Index, "/_", to_bin(Op), Str];
        _ ->       [Index, "/", to_bin(Type), "/_", to_bin(Op), Str]
    end.


%% @private
post_index(all) -> [];
post_index(Index) -> ["/", Index].


%% @private
to_bin(Term) ->
    nklib_util:to_binary(Term).

%% @private
to_int(Term) ->
    nklib_util:to_integer(Term).
